<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Functional Rust - An Exploration - LambdaDays 2018</title>
    <style>
     html, body {
       color: #333;
     }
     p, li {
       font-size: 28px;
       line-height: 1.5;
     }
     .center h1, .center h2, .center h3 {
       line-height: 1.5;
     }
     h1 {
       margin-bottom: 1em;
     }
     blockquote {
       margin: 0;
       padding: .1rem 1rem;
       color: #666;
       border-left: 5px solid #666;
     }
     .img-s {
       display: inline-block;
       width: 70px;
       height: auto;
       vertical-align: middle;
     }
     .img-s img {
       width: 100%;
     }
     .img-m {
       display: block;
       margin: auto;
       width: 350px;
       height: auto;
       vertical-align: middle;
     }
     .img-m img {
       width: 100%;
     }
     .img-l {
       display: block;
       margin: auto;
       width: 800px;
       height: auto;
       vertical-align: middle;
     }
     .img-l img {
       width: 100%;
     }
     a,
     a:visited {
       color: inherit
     }
     a:hover,
     a:focus,
     a:active {
       color: #D89018;
     }

     .remark-code {
       max-height: 400px;
       overflow: scroll
     }

     .small {
       font-size: 0.7em;
     }

    </style>
  </head>
  <body>
    <textarea id="source">

      # Functional Rust

      ## An Exploration

      Lisa Passing - LambdaDays 2018

      ---

      # $ whoami

      --

      Berlin based web dev, hobby game dev, wannabe digital artist.

      --

      Co-organizer of [ClojureBridge Berlin](http://clojurebridge-berlin.org/) and various [CryptoParties](https://www.cryptoparty.in/berlin).

      ---

      class: center, middle
      ![Rust logo](img/rust-logo.jpg)

      ---

      # Rust is

      --

      - a systems progamming language (like C/ C++)

      --

      - relatively young (1.0.0 was released in 2015)


      --

      - increasingly gaining popularity

      ---

      class: center, middle

      ## Is Rust a functional language?

      --

      # NO!

      ---

      class: center, middle
      ## Why are we even here then?

      ---

      background-image: url(img/shrug2.gif)
      background-size: cover

      ---

      ## Two reasons

      --

      1. We can still apply functional thinking non-functional languages

      --

      2. Rust drew inspiration from functional languages

      --

      3.* Rust will be important and knowing it will be useful


      .small[`* one-off-error joke`]

      ---

      background-image: url(img/humble-1.png)
      background-size: cover

      ---

      background-image: url(img/humble-2.png)
      background-size: contain

      ---

      background-image: url(img/humble-3.png)
      background-size: contain

      ---

      class: center, middle

      ## Let's get functional

      ---

      class: center, middle
      Ready?

      ---

      # Disclaimer

      --

      This is not a complete overview of Rust.

      --

      A lot of important concepts in Rust are left out because they go beyond the scope of this talk.

      ---

      class: center, middle
      Ready?

      ---

      # Checklist

      ☐ Immutability

      ☐ Functions

      ☐ Types and Traits

      ☐ Higher Order Functions

      ---

      # (Im)Mutability

      --

      - per default all variables are immutable

      --

      ```rust
      fn main() {

        let a = "hello";
        a = "foo";
      }
      ```

      --

      ```rust
      error[E0384]: cannot assign twice to immutable variable `a`
       --> src/main.rs:4:5
        |
      3 |     let a = "Hello";
        |         - first assignment to `a`
      4 |     a = "foo";
        |     ^^^^^^^^^ cannot assign twice to immutable variable

      error: aborting due to previous error
      ```
      ---

      # (Im)Mutability

      - per default all variables are immutable

      --

      - but you can shadow them

      --

      ```rust
      let a = "hello";

      let a = "foo";
      ```

      ---

      # (Im)Mutability

      - per default all variables are immutable

      - but you can shadow them

      --

      - you have the option to create them mutably

      --

      ```rust
      let mut a = "hello";

      a = "foo";
      ```

      ---

      # (Im)Mutability

      - per default all variables are immutable

      - but you can shadow them

      - you have the option to create them mutably

      --

      - contants are always immutable

      ```rust
      const MAX_POINTS: u32 = 1000;
      ```

      --

      - _Sidenote_: type annotation on variable assignment is optional

      ---

      # (Im)Mutability .small[pt2]

      --

      - Rust does not implement persistent datastructures

      --

        ➪ copying and allocating large quantities of data comes with performance cost

      --

      - The Borrow-checker* takes care of a lot of involuntary mutation

      .small[`* The Borrow-checker is a large topic that is left out in this talk`]

      ---

      # Checklist

      ☑ Immutability

      ☐ Functions

      ☐ Types and Traits

      ☐ Higher Order Functions

      ---

      # Functions

      --

      - indicated by `fn` keyword

      --

      ```rust
      fn main() {
        println!("Hello World");
      }
      ```

      ---

      # Functions

      - indicated by `fn` keyword

      --

      - a function can have parameters

      --

      - if it has params, types must be annotated

      --

      ```rust
      fn main() {
        another_function(7);
      }

      fn another_function(x: u32) {
        println!("Hello {}", x);
      }
      ```

      ---

      # Functions

      - indicated by `fn` keyword

      - a function can have parameters

      - if it has params, types must be annotated

      --

      - if it returns a value, types must be annotated

      ---

      # Functions .small[continued]

      ```rust
      fn main() {
        println!("Hello {}", another_function(7));
      }

      fn another_function(x: u32) -> u32 {
        x
      }
      ```
      --
      ```bash
      => Hello 7
      ```
      ---

      class: center, middle
      # What does a `fn` return?
      ---

      # Statements vs Expressions
      --

      - Statements perform actions

      - Expressions return values

      --

      - Expressions do not have a trailing semicolon

      ---

      # Statements vs Expressions .small[pt2]

      --
      - Function declarations are statements

      - Function calls are expressions

      --

      - Statements __cannot__ be assigned to variables, expressions __can__

      ---

      # Checklist

      ☑ Immutability

      ☑ Functions

      ☐ Types and Traits

      ☐ Higher Order Functions

      ---

      # Types and Traits

      --

      - Rust is statically typed with type inference

      ---

      # Generic Types and Traits

      --

      - `Generics` are stand-ins for concrete types

      --

      - `Traits` allow implementation of functionality

      --

        - concrete types

      --

        - on generic types

      ---


      # Monads, maybe?

      --

      - `Enum`s are types with enumerated possible values

      --

      - `Enum variants` can hold `generic` Types

      --

      - Rust has some pretty neat `Enums` build in

      --

      ```rust
      enum Option<T> {
        Some<T>,
        None,
      }
      ```
      --

      ```rust
      enum Result<T, E> {
        Ok(T),
        Err(E)
      }
      ```

      ---

      # Checklist

      ☑ Immutability

      ☑ Functions

      ☑ Types and Traits

      ☐ Higher Order Functions

      ---

      # Higher Order Functions

      --

      - Rust cannot return functions, since declarations are statements

      --

      - Rust cannot take a function as param for the same reason

      --

      __But__ there is a special case ...


      ---

      # Closures in Rust

      --

      - anonymous functions that can capture values from their context

      --

      - can be saved in variables and used as arguments

      --

      ```rust

      let a_clojure = |num| {
        num * num
      }

      ```
      --

      ```rust
      a_clojure(7)
      ```
      ---

      # Closures in Rust

      - anonymous functions that can capture values from their context

      - can be saved in variables and used as arguments

      - type annotations are optional

      --

      - _Sidenote_: [example implementation of memoization with closures](https://doc.rust-lang.org/book/second-edition/ch13-01-closures.html#storing-closures-using-generic-parameters-and-the-fn-traits)

      ---

      # Enter Iterators

      --

      - `Trait` that handles logic to manage the iteration of a sequence

      --

      ```rust
      let victor = vec!["CA", "CO", "ID", "IN", "IO", "MT", "NY", "SD"];

      let vic_iter = victor.iter();

      ```

      --

      ```rust
      for v in vic_iter {
        println!("{}", v);
      }
      ```

      ---

      # Enter Iterators

      - `Trait` that handles logic to manage the iteration of a sequence

      - __consuming adaptors__ use up the iterator

      --

      - __iterator adaptors__ can transform one iterator into another

      --

      - can take closures as argument

      --

      ```rust
      let v1 = vec![1, 2, 3, 4];
      let v2 = v1.iter().map(|x| x + 1).collect();
      ```

      ---

      # Iterators .small[pt2]

      --

      - one of Rust's zero cost abstractions

      --

      - creates readable high level code

      --

      - implementable on your own types

      ---

      ## Implementing the Iterator trait
      --

      ```rust
      struct Counter {
        count: u32,
      }

      impl Counter {
        fn new() -> Counter {
          Counter { count: 0 }
        }
      }
      ```

      .small[[Example taken from the book](https://doc.rust-lang.org/book/second-edition/ch13-02-iterators.html#implementing-the-iterator-trait-to-create-our-own-iterators)]
      ---

      ## Implementing the Iterator trait .small[pt2]
      --

      ```rust

      impl Iterator for Counter {
        type Item = u32;

        fn next(&mut self) -> Option<Self::Item> {
          self.count += 1;

          if self.count < 6 {
            Some(self.count)
          } else {
            None
          }
        }
      }
      ```

      .small[[Example taken from the book](https://doc.rust-lang.org/book/second-edition/ch13-02-iterators.html#implementing-the-iterator-trait-to-create-our-own-iterators)]

      ---

      # Checklist

      ☑ Immutability

      ☑ Functions

      ☑ Types and Traits

      ☑ Higher Order functions

      ---

      # Checklist

      ☑ Immutability

      ☑ Functions, statements and expressions

      ☑ Generic Types, Enums and Traits

      ☑ Closures and Iterators

      ---

      class: center, middle

      phew

      ---

      class: center, middle

      ## Is that all there is?

      ---

      class: center, middle

      # Explore functional Rust yourself!

      ---

      ## Special <3

      **Florian** ([@argorak](https://twitter.com/Argorak)) and **Andrew** ([@andrewhobden](https://twitter.com/andrewhobden))

      for reviewing this talk!

      **Carol** ([@carols10cents](https://twitter.com/Carols10cents))

      for the amazing work on the [2nd edition Rust book](https://doc.rust-lang.org/book/second-edition/)!

      ---

      # Thank you!

      mail[at]lislis[dot]de

      https://github.com/lislis

      (Slides) https://lislis.de/talks/fp-rust

    </textarea>
    <script src="remark.min.js"></script>
    <script>var slideshow = remark.create({
       ratio: '16:9',
       navigation: {
         scroll: false
       }});
    </script>
  </body>
</html>
