<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Rust and Haskell, sitting in a tree  - Lambda.World 2018</title>
    <style>
     html, body {
       color: #333;
     }
     p, li {
       font-size: 28px;
       line-height: 1.5;
     }
     .center h1, .center h2, .center h3 {
       line-height: 1.5;
     }
     h1 {
       margin-bottom: 1em;
     }
     blockquote {
       margin: 0;
       padding: .1rem 1rem;
       color: #666;
       border-left: 5px solid #666;
     }
     a,
     a:visited {
       color: inherit
     }
     a:hover,
     a:focus,
     a:active {
       color: #D89018;
     }

     .remark-code {
       max-height: 400px;
       overflow: scroll
     }

     .small {
       font-size: 0.7em;
     }

     .title {
       font-size: 1.5em;
       margin-bottom: 0;
     }
     h1 + h1 {
       margin-top: -0.5em;
     }

     .flex {
       display: flex;
       justify-content: space-evenly;
     }
     .flex-helper {}

     .contain {
       background-size: contain !important;
     }

    </style>
  </head>
  <body>
    <textarea id="source">

      # .title[Rust and Haskell],
      # sitting in a tree

      .flex[
      ![Lambda.World](/img/lambdaworld-160x160.png)

      .flex-helper[
      Lisa '[lislis](https://lislis.de/)' Passing

      [Lambda.World C√°diz](http://cadiz.lambda.world/) 2018]]

      ---

      # $ whoami

      --

      Hi, I'm Lisa üëã

      --

      Web dev, game jammer, wannabe digital artist, fp enthusiast, etc

      --

      Co-organizer of [ClojureBridge Berlin](http://clojurebridge-berlin.org/)

      --

      I thought of a pun when writing the talk title,
      but decided the pun doesn't work when writing the talk
      `¬Ø\_(„ÉÑ)_/¬Ø`

      ---

      class: center, middle
      ![Rust logo](img/rust-logo.jpg)

      ---

      class: contain
      background-image: url(img/rust-lang-website.png)

      ---

      class: contain
      background-image: url(img/rust-lang-inference.png)

      ---

      class: contain
      background-image: url(img/rust-lang-pattern.png)

      ---

      class: contain
      background-image: url(img/rust-lang-traits.png)

      ---

      class: contain
      background-image: url(img/rust-lang-zero.png)

      ---

      # Let's see

      --

      - type inference

      - pattern matching

      - trait-based generics

      - zero-cost abstractions

      --

      ### Could make a pretty good fp talk ü§î

      ---

      class: center, middle

      # Type inference

      ---

      class: middle
      background-image: url(img/haskell.svg)

      ## _Did someone say type inference?_

      ---

      # Type inference in Haskell




      ---

      # Types in Rust

      --

      - Types are infered when possible

      --

      ```rust
      fn main() {

        let elem: u8 = 5;
        let mut vec = Vec::new();

        vec.push(elem);

        println!("{:?}", vec);
      }
      ```

      --

      ```bash
      [5]
      ```

      ---

      # Types in Rust

      - Types are infered when possible

      - Functions have to have type annotations

      --

      ```rust
      fn main() {
        println!("Hello {}", id(7));
      }
      fn id(x: u32) -> u32 {
        x
      }
      ```
      ```bash
      Hello 7
      ```

      ---

      # Pattern matching

      ---

      # Traits and Generics

      ---

      # Zero-cost abstractions

      ---

      ---

      # Checklist

      ‚òë Immutability

      ‚òë Functions

      ‚òê Types and Traits

      ‚òê Higher Order Functions

      ---

      # Types

      --

      - Rust is statically typed

      - with type inference

      ---

      # Generic Types and Traits

      --

      - `Generics` are stand-ins for concrete types

      --

      - `Traits` abstact implementation of functionality

      --

        - on concrete types

      --

        - on generic types

      --

      ```rust
      impl Log for <T : Debug> {}
      ```

      ---

      # Enums and Pattern matching
      --

      - `Enums` are types with enumerated possible values

      --

      - `Enum variants` can hold `generic` Types

      --

      ```rust
      enum Option<T> {
        Some<T>,
        None,
      }
      ```
      ---

      # Enums and Pattern matching

      - `Enums` are types with enumerated possible values

      - `Enum variants` can hold `generic` Types


      ```rust
      fn plus_one(x: Option<i32>) -> Option<i32> {
        match x {
          None => None,
          Some(i) => Some(i + 1),
        }
      }
      ```

      --

      ```rust
      plus_one(Some(5)).unwrap();
      ```

      ---

      # Checklist

      ‚òë Immutability

      ‚òë Functions

      ‚òë Types and Traits

      ‚òê Higher Order Functions

      ---

      # Higher Order Functions

      --

      - function names are part of a function's type

      --

        ‚û™ functions with same signature are still different

      --

        ‚û™ creating functions dynamically and passing them around is not (easily) possible

      --

      - can't capture values from environment

      ---

      class: middle, center
      But there is another way!

      ---

      # Closures

      --

      - anonymous functions that can capture values from their environment

      --

      - can be saved in variables and used as arguments

      --

      ```rust

      let a_closure = |num| {
        num * num
      }

      ```
      --

      ```rust
      a_closure(7)
      ```
      ---

      # Closures

      - anonymous functions that can capture values from their environment

      - can be saved in variables and used as arguments

      - type annotations are optional

      --

      - _Sidenote_: [example implementation of memoization with closures](https://doc.rust-lang.org/book/second-edition/ch13-01-closures.html#storing-closures-using-generic-parameters-and-the-fn-traits)

      ---

      # Iterators

      --

      - `Trait` that handles logic to manage the iteration of a sequence

      --

      - `Iterators` are thread-safe

      --

      - `Iterators` are lazy

      --

      ```rust
      let v1 = vec![1, 2, 3, 4, 5];

      let v2 = v1.iter();

      ```

      --

      ```rust
      for v in v2 {
        println!("{}", v);
      }
      ```

      ---

      # Iterators .small[pt2]

      - can take closures as argument

      --

      - __consuming adaptors__ use up the `Iterator`

      --

      ```rust
      let v1 = vec![1, 2, 3, 4];
      let v2 = v1.iter().fold(0, |acc, &x| acc + x);
      ```

      --

      - __iterator adaptors__ can transform one `Iterator` into another

      --

      ```rust
      let v1 = vec![1, 2, 3, 4];
      let v2 = v1.iter().map(|x| x + 1).fold(0, |acc, x| acc + x);
      ```

      ---

      ## Implementing the Iterator trait
      --

      ```rust
      struct Counter {
        count: u32,
      }

      impl Counter {
        fn new() -> Counter {
          Counter { count: 0 }
        }
      }
      ```

      .small[[Example taken from the book](https://doc.rust-lang.org/book/second-edition/ch13-02-iterators.html#implementing-the-iterator-trait-to-create-our-own-iterators)]
      ---

      ## Implementing the Iterator trait .small[pt2]
      --

      ```rust

      impl Iterator for Counter {
        type Item = u32;

        fn next(&mut self) -> Option<Self::Item> {
          self.count += 1;

          if self.count < 6 {
            Some(self.count)
          } else {
            None
          }
        }
      }
      ```

      ---

      ## Implementing the Iterator trait .small[pt3]

      --

      ```rust

      fn main() {
        let counter = Counter::new();

        let even_nums: Vec<u32> = counter.filter(|x| {
          if x % 2 == 0 {
            true
          } else {
            false
          }
        }).collect();

        println!("Even: {:?}", even_nums);
      }

      ```
      --

      ```bash
      Even: [2, 4]
      ```

      ---

      # Checklist

      ‚òë Immutability

      ‚òë Functions

      ‚òë Types and Traits

      ‚òë Higher Order functions

      ---

      class: center, middle

      phew

      ---

      class: center, middle

      ## That's (almost) all, folks!

      ---

      class: center, middle

      # Explore functional Rust yourself!

      ---

      ## Special <3

      **Florian** ([@argorak](https://twitter.com/Argorak)) and **Andrew** ([@andrewhobden](https://twitter.com/andrewhobden))

      for reviewing this talk!

      **Carol** ([@carols10cents](https://twitter.com/Carols10cents))

      for the amazing work on the [2nd edition Rust book](https://doc.rust-lang.org/book/second-edition/)!

      ---

      # Thank you!

      mail[at]lislis[dot]de

      https://github.com/lislis

      (Slides) https://lislis.de/talks/fp-rust

    </textarea>
    <script src="remark.min.js"></script>
    <script>var slideshow = remark.create({
       ratio: '4:3',
       navigation: {
         scroll: false
       }});
    </script>
  </body>
</html>
