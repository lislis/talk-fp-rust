<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Functional Rust - An Exploration  - partial::Conf 2018</title>
    <link href="styles.css" rel="stylesheet">
  </head>
  <body>
    <textarea id="source">
      # .title[Functional Rust]
      # .subtitle[An Exploration]

      Lisa '[lislis](https://lislis.de/)' Passing

      [partial::Conf](http://partialconf.com/) 2018

      ---

      ## $ whoami

      --

      Developer at [Open Knowledge Foundation DE](https://okfn.de)

      --

      Game jammer, wannabe artist

      --

      FP through ClojureScript

      --

      Rustacean since early 2017

      ---

      class: center, middle
      ![Rust logo](img/rust-logo.jpg)

      ## Rust!

      ---

      ## Rust is

      --

      - a systems programming language

      --

      - imperative, multi-paragigm

      --

      - lifetimes and ownership

      --

        &rArr; no garbage collection and no manual memory management

      --

      - young, but popular ([1](https://insights.stackoverflow.com/survey/2016#technology-most-loved-dreaded-and-wanted), [2](https://insights.stackoverflow.com/survey/2017#most-loved-dreaded-and-wanted), [3](https://insights.stackoverflow.com/survey/2018/#most-loved-dreaded-and-wanted))

      ---

      ## Bringing together two worlds

      --

      - systems programmers who are used to bare metal

      --

      - higher level programmers who are used to abstractions

      ---

      class: center, middle, interm

      # Let's explore some functional features

      ---

      class: center, middle, invert

      # Functions

      ---

      .p-right[Functions in Rust .small[(pt 1)]]

      --

      ## Definition

      --

      ```rust
      fn main() {
        println!("Hello World");
      }
      ```
      ---

      .p-right[Functions in Rust .small[(pt 1)]]

      ## Definition

      ```rust
      fn head(v:Vec<u32>) -> u32 {
        v[0]
      }

      fn main() {
        let vector = vec![43, 567, 2, 34];
        println!("{}", head(vector));
      }
      ```
      --

      - types of variables can be inferred

      --

      - must annotate types of params and return values

      --

      - returns last expression (_no trailing `;`_)

      ---

      .p-right[Functions in Rust .small[(pt 2)]]

      ## Recursion

      --

      ```rust

      fn fibonacci(nth: i32) -> i32  {
        match nth {
          0 =>  { 0 },
          1 => { 1 },
          n => {
            fibonacci( n - 1 ) + fibonacci( n - 2)
          }
        }
      }

      fn main() {
        println!("{}", fibonacci(6));
      }

      ```

      --

      ```bash
      8
      ```

      ---

      .p-right[Functions in Rust .small[(pt 3)]]

      --

      ## Higher order functions

      --

      Take a function as param and/or return a function

      --

      - we'd have to know the types beforehand to annotate them

      --

      - the types of two named functions with the same signature still have different

      --

      How do we work around that?

      ---

      .p-right[Functions in Rust .small[(pt 4)]]

      ## Closures

      --

      - anonymous functions

      --

      - can capture their environment

      --

      ```rust
      let square = |num| {
        num * num
      }
      ```

      --

      - type annotations are optional

      ---

      .p-right[Functions in Rust .small[(pt 5)]]

      ## HOF cont.

      --

      _Find the sum of all odd squares that are smaller than 10,000._ .small[[haskell](http://learnyouahaskell.com/higher-order-functions#maps-and-filters), [rust](https://doc.rust-lang.org/stable/rust-by-example/fn/hof.html)]

      --

      ```rust
      fn is_odd(n: u32) -> bool {
        n % 2 == 1
      }

      fn main() {
        let upper = 10000;

        let sum_of_squared_odd_numbers: u32 =
          (0..).map(|n| n * n)
               .take_while(|&n_squared| n_squared < upper)
               .filter(|&n_squared| is_odd(n_squared))
               .fold(0, |acc, n_squared| acc + n_squared);

        println!("Result: {}", sum_of_squared_odd_numbers);
      }
      ```

      ---

      class: center, middle

      ## Can you explain Iterator again?

      --

      Just a sec!

      ---

      class: center, middle, invert

      # Generics and traits

      ---

      ## Generics and traits

      --

      - generics

      --

      - traits

      --

      - trait bounds

      ---

      class: center, middle, invert

      # The `Iterator` trait

      ---

      ## `Iterator`s

      - thread safe

      - are lazy

      - adaptors convert the type of Iterator

      - consumers kick off evaluation

      ---

      class: center, middle, invert

      # Structs and enums

      ---

      ## Structs and enums

      --

      - structs

      --

      - enums

      ---

      class: center, middle, invert

      # Pattern matching

      ---

      ## Pattern matching!

      --

      - with structs or enums

      --

      - compare with Haskell

      --

      - error handling

      ---

      class: center, middle, invert

      # Zero cost abstractions

      --

      **Use abstractions _without_ additional performance cost!**

      ---

      ## Thank you!

      .no-bullets[
      - ðŸ“§ mail@lislis.de
      - ðŸ˜ lislis@toot.cat
      - ðŸ™ https://github.com/lislis
      - ðŸ“½ï¸ https://lislis.de/talks/partial-conf-2018/]

      ### Resources

      - [The Rust Programming Language](https://doc.rust-lang.org/book/second-edition/index.html)
      - [Rust by Example](https://doc.rust-lang.org/rust-by-example/)
      - [Learn you a Haskell](http://learnyouahaskell.com/chapters)

    </textarea>
    <script src="remark.min.js"></script>
    <script>var slideshow = remark.create({
       ratio: '4:3',
       navigation: {
         scroll: false
       }});
    </script>
  </body>
</html>
