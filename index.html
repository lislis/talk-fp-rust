<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Rust and Haskell, sitting in a tree  - Lambda.World 2018</title>
    <link href="styles.css" rel="stylesheet">
  </head>
  <body>
    <textarea id="source">
      # .title[Rust and Haskell]
      # .subtitle[sitting in a tree]

      .flex[
      ![Lambda.World](/img/lambdaworld-160x160.png)

      .flex-helper[
      Lisa '[lislis](https://lislis.de/)' Passing

      [Lambda.World C√°diz](http://cadiz.lambda.world/) 2018]]

      ---

      # $ whoami

      --

      Hi, I'm Lisa üëã

      --

      Web dev, game jammer, wannabe digital artist, fp enthusiast, etc

      --

      Co-organizer of [ClojureBridge Berlin](http://clojurebridge-berlin.org/)

      --

      I thought of a pun when writing the talk title,
      but decided the pun doesn't work when writing the talk
      `¬Ø\_(„ÉÑ)_/¬Ø`

      ---

      class: center, middle
      ![Rust logo](img/rust-logo.jpg)

      ---

      class: contain
      background-image: url(img/rust-lang-website.png)

      ---

      class: contain
      background-image: url(img/rust-lang-inference.png)

      ---

      class: contain
      background-image: url(img/rust-lang-pattern.png)

      ---

      class: contain
      background-image: url(img/rust-lang-traits.png)

      ---

      class: contain
      background-image: url(img/rust-lang-zero.png)

      ---

      # Let's see

      --

      - type inference

      - pattern matching

      - trait-based generics

      - zero-cost abstractions

      --

      ### Could make a pretty good fp talk ü§î

      ---

      class: center, middle, invert

      # Type inference

      ---

      class: middle
      background-image: url(img/haskell.svg)

      > Did someone say **type inference**?

      ---
      layout: true
      ## Type inference in Haskell

      ---

      --
      ```haskell
      doubleMe x = x * 2

      ```
      ---

      ```haskell
      doubleMe x = x * 2

      doubleMe 8
      ```

      ```haskell
      16
      ```
      --

      Haskell infers that this can only work with numbers.

      --

      ```haskell
      doubleMe "this is a trick!"

      doubleMe []
      ```
      --

      ```bash
      ERROR!
      ```
      --

      We get an error for everything else.

      ---

      This works with lists, too!

      --

      ```haskell
      doubleFirstOfList xs = head xs * 2
      ```
      --

      ```haskell
      doubleFirstOfList [239, 3482, 23, 23]
      ```
      --

      ```bash
      478
      ```

      ---

      We don't have to annotate types,

      but it's nice when we do.

      --

      ```haskell
      doubleFirstOfList' :: [Int] -> Int

      doubleFirstOfList' xs = head xs * 2
      ```
      ---

      layout: false
      class: middle
      background-image: url(img/rust-logo.jpg)

      > What about Rust?
      ---

      layout: true
      ## Type inference in Rust

      ---

      --

      - Types are infered when possible

      --

      ```rust
      fn main() {
        let elem = 5;

        let doubleElem = elem * 2;

        println!("{}", doubleElem);
      }
      ```
      --

      ```bash
      10
      ```
      ---

      ```rust
      fn main() {
        let vector = vec![2, 16, 348];

        let double_first_of_vec = vector[0] * 2;

        println!("{}", double_first_of_vec);
      }
      ```
      --

      ```bash
      4
      ```
      ---

      .one-p[
      Function params and return values

      have to always be annotated!]

      --

      ```rust
      fn double_first_of_vec(v:Vec<u32>) -> u32 {
        v[0] * 2
      }

      fn main() {
        let vector = vec![2, 16, 348];
        println!("{}", double_first_of_vec(vector));
      }

      ```
      --
      ```bash
      4
      ```

      ---

      layout: false
      class: center, middle, invert

      # Trait-based generics

      ---

      ## What are generics in Rust?

      --

      An abstract stand-in for a concrete values

      --

      ```rust
      fn first_and_last<T>(v: &Vec<T>) -> Vec<&T> {
        vec![v.first().unwrap(),
             v.iter().last().unwrap()]
      }
      ```

      --

      ```rust
      fn main() {
        let nums = vec![2, 16, 348];
        println!("{:?}", first_and_last(&nums));

        let strings = vec!["Hello", "a", "foo", "World"];
        println!("{:?}", first_and_last(&strings));
      }

      ```
      --
      ```bash
      [2, 348]
      ["Hello", "World"]

      ```

      ---

      class: middle
      background-image: url(img/haskell.svg)

      > Oh, did you mean **type variables**?

      ---

      ## Type variables in Haskell

      --

      ```haskell
      firstAndLast :: [a] -> [a]
      firstAndLast xs = [head xs, last xs]
      ```

      --
      ```haskell
      firstAndLast [45, 28, 645, 23]
      ```

      ```bash
      [45, 23]
      ```

      ---

      ## What are Traits in Rust?

      --

      .one-p[
      Traits define behaviour that Types can implement]

      --

      Example `Display` Trait for user facing string output.

      ---

      class: contain
      background-image: url(img/display-trait.png)

      ---
      ### Implementing `Display` on a type

      --

      ```rust

      use std::fmt;

      struct Point {
        x: i32,
        y: i32
      }

      ```

      ---

      ### Implementing `Display` on a type

      ```rust

      use std::fmt;

      struct Point {
        x: i32,
        y: i32
      }

      impl fmt::Display for Point {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
          write!(f, "({}, {})", self.x, self.y)
        }
      }

      ```
      ---

      ### Implementing `Display` on a type

      ```rust

      use std::fmt;

      struct Point {
        x: i32,
        y: i32
      }

      impl fmt::Display for Point {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
          write!(f, "({}, {})", self.x, self.y)
        }
      }

      let p = Point { x: 0, y: 0 };

      println!("The point is: {}", p);

      ```
      --

      ```bash
      The point is: (0, 0)
      ```

      ---

      class: middle
      background-image: url(img/haskell.svg)

      > Sounds a lot like **type classes**

      ---

      ## Type classes in Haskell

      --

      Let's look at the `Show` type class

      --

      ```haskell
      data Point = Point { x :: Int
                         , y :: Int
                         } deriving (Show)

      ```
      --

      ```haskell
      let p1 = Point 2 3

      show p1
      ```
      --

      ```bash
      Point {x = 2, y = 3}
      ```
      ---

      Alternatively we can make a function

      ```haskell
      display :: Point -> String
      display (Point {x=x, y=y}) = "The point is (" ++ show x ++
                                   "," ++ show y ++")"
      ```
      --

      ```haskell
      let p = Point 0 0
      display p
      ```
      --

      ```bash
      The point is (0, 0)
      ```
      ---

      ## So trait-based generics are ...?

      --


      --

      @todo


      Surprise! Class constraints!

      ---

      class: center, middle

      # Pattern matching

      ---

      class: middle
      background-image: url(img/haskell.svg)

      ## _Did someone say 'pattern matching'?_

      ---

      ## Pattern matching in Haskell

      --

      - @todo

      ---

      class: center, middle

      # Zero-cost abstractions

      ---

      ## Zero-cost abstractions

      --

      - Having higher level tools without additional performance cost!

      --

      - Let's look at

      --

        - Higher order functions

      --

        - Closures

      ---

      ### Higher order functions


      @todo

      ---

      ### Closures

      #todo

      ---

      # So is Rust a functional language?

      --

      Well, no.

      It very imperative with multi-paragim cherry-picks

      --

      But it definitely learned some good things from the functional world

      and Haskell specifically

      ---

      ## Thank you!

      .no-bullets[
      - üìß mail@lislis.de
      - üêò lislis@toot.cat
      - üêô https://github.com/lislis
      - üìΩÔ∏è https://lislis.de/talks/fp-rust]

      ### Resources

      - [The Rust Programming Language](https://doc.rust-lang.org/book/second-edition/index.html)
      - [Rust by Example](https://doc.rust-lang.org/rust-by-example/)
      - [Learn you a Haskell](http://learnyouahaskell.com/chapters)

    </textarea>
    <script src="remark.min.js"></script>
    <script>var slideshow = remark.create({
       ratio: '4:3',
       navigation: {
         scroll: false
       }});
    </script>
  </body>
</html>
